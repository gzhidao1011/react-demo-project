# 第五阶段：前端集成

**预计时间**：4-5 天

## 概述

本阶段实现前端注册页面、登录页面、Token 存储策略、Token 刷新机制和 API 集成，完成前后端联调。

**开发方式**：采用测试驱动开发（TDD），先编写单元测试，等测试通过后再实现功能代码。

**功能范围**：
- 注册功能：注册 Schema、注册页面、注册 API 集成
- 登录功能：登录 Schema、登录页面、登录 API 集成
- Token 管理：Token 存储策略、Token 刷新机制
- API 集成：请求拦截器、响应拦截器、错误处理

## TDD（测试驱动开发）实现方式

### 什么是 TDD？

TDD（Test-Driven Development）是一种软件开发方法论，核心思想是**先写测试，再写代码**。它遵循 **Red-Green-Refactor** 循环：

```
┌─────────┐
│   Red   │ ← 1. 先写测试，测试失败（功能不存在）
└────┬────┘
     │
     ↓
┌─────────┐
│  Green  │ ← 2. 写最小实现，让测试通过
└────┬────┘
     │
     ↓
┌──────────┐
│ Refactor │ ← 3. 重构代码，保持测试通过
└────┬─────┘
     │
     └─────→ 重复循环
```

### 国外主流的 TDD 实践

#### 1. Red-Green-Refactor 循环

**第一步：Red（红色）** - 编写失败的测试
```typescript
// 1. 先写测试（此时功能还不存在，测试会失败）
describe("validateEmail", () => {
  it("应该接受有效的邮箱格式", () => {
    // Arrange: 准备测试数据
    const email = "user@example.com"
    
    // Act: 调用函数（函数还不存在）
    const result = validateEmail(email)
    
    // Assert: 验证结果（测试会失败）
    expect(result).toBe(true)
  })
})
```

**第二步：Green（绿色）** - 写最小实现让测试通过
```typescript
// 2. 写最小实现，让测试通过
export function validateEmail(email: string): boolean {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)
}
```

**第三步：Refactor（重构）** - 优化代码，保持测试通过
```typescript
// 3. 重构代码，提高代码质量
export function validateEmail(email: string): boolean {
  if (!email || typeof email !== "string") {
    return false
  }
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  return emailRegex.test(email.trim())
}
```

#### 2. AAA 模式（Arrange-Act-Assert）

这是**国外最主流的测试结构模式**，每个测试用例都遵循三个步骤：

```typescript
it("应该接受有效的邮箱格式", () => {
  // ✅ Arrange（准备）：设置测试数据和环境
  const email = "user@example.com"
  
  // ✅ Act（执行）：调用被测试的函数
  const result = validateEmail(email)
  
  // ✅ Assert（断言）：验证结果
  expect(result).toBe(true)
})
```

**优势**：
- ✅ 结构清晰，易于理解
- ✅ 测试意图明确
- ✅ 符合国外主流实践（Jest、Vitest、JUnit 等）

#### 3. 测试文件组织方式（Co-located Tests）

**国外主流做法**：测试文件与源文件放在同一目录（co-located）

```
packages/utils/
├── src/
│   ├── validate-email.ts          # 源代码文件
│   ├── validate-email.test.ts     # 测试文件（紧邻源文件）
│   ├── auth.ts
│   └── auth.test.ts
```

**采用此方式的知名项目**：
- ✅ React（Facebook）
- ✅ Vue.js
- ✅ Next.js（Vercel）
- ✅ Remix
- ✅ Svelte

**优势**：
- ✅ 易于发现：测试文件紧邻源文件
- ✅ 维护性好：修改代码时，测试文件就在旁边
- ✅ 导入简单：相对路径导入更直观

#### 4. 测试金字塔（Test Pyramid）

国外主流实践遵循测试金字塔原则：

```
        /\
       /E2E\        ← 10% E2E 测试（少量）
      /------\
     /Integration\  ← 20% 集成测试（中等）
    /------------\
   /   Unit Tests  \ ← 70% 单元测试（大量）
  /----------------\
```

**测试分布**：
- **单元测试（70%）**：快速、隔离、测试单个函数/组件
- **集成测试（20%）**：测试组件/模块之间的交互
- **E2E 测试（10%）**：测试完整用户流程

#### 5. 测试命名规范

**国外主流做法**：使用描述性命名，清晰说明测试目的

```typescript
// ✅ 推荐：描述性命名
it("应该接受有效的邮箱格式", () => { ... })
it("应该拒绝无效的邮箱格式", () => { ... })
it("应该处理空字符串", () => { ... })

// ❌ 不推荐：模糊命名
it("test email", () => { ... })
it("email validation", () => { ... })
```

#### 6. Mock 和 Stub 的使用

**国外主流做法**：使用 Mock 隔离外部依赖

```typescript
import { vi } from "vitest"

// Mock API 调用
vi.mock("./api", () => ({
  fetchUser: vi.fn(() => Promise.resolve({ id: "123", name: "John" })),
}))

// Mock 浏览器 API
const localStorageMock = {
  getItem: vi.fn(),
  setItem: vi.fn(),
  removeItem: vi.fn(),
}
global.localStorage = localStorageMock as any
```

**原则**：
- ✅ Mock 外部依赖（API、数据库、浏览器 API）
- ✅ 保持测试独立和快速
- ✅ 避免过度 Mock，保持测试真实性

#### 7. 测试覆盖率要求

**国外主流标准**：
- **整体覆盖率**：≥ 80%
- **关键模块**：≥ 90%
- **工具函数**：≥ 90%
- **业务逻辑**：≥ 70%

#### 8. TDD 工作流程示例

以登录功能为例，展示完整的 TDD 流程：

**步骤 1：编写 Schema 测试（Red）**
```typescript
// packages/schemas/src/auth/login.schema.test.ts
describe("loginSchema", () => {
  it("应该接受有效的邮箱和密码", () => {
    const validData = {
      email: "user@example.com",
      password: "password123",
    }
    expect(() => loginSchema.parse(validData)).not.toThrow()
  })
  
  it("应该拒绝无效的邮箱格式", () => {
    const invalidData = {
      email: "invalid-email",
      password: "password123",
    }
    expect(() => loginSchema.parse(invalidData)).toThrow()
  })
})
```

**步骤 2：运行测试（Red）**
```bash
pnpm test
# 测试应该失败（因为 Schema 还未实现）
```

**步骤 3：实现 Schema（Green）**
```typescript
// packages/schemas/src/auth/login.schema.ts
import { z } from "zod"

export const loginSchema = z.object({
  email: z.string().email("请输入有效的邮箱地址"),
  password: z.string().min(1, "密码不能为空"),
})
```

**步骤 4：运行测试（Green）**
```bash
pnpm test
# 测试应该通过
```

**步骤 5：重构（Refactor）**
```typescript
// 优化 Schema，添加更多验证规则
export const loginSchema = z.object({
  email: z
    .string()
    .min(1, "邮箱不能为空")
    .email("请输入有效的邮箱地址"),
  password: z
    .string()
    .min(1, "密码不能为空")
    .min(6, "密码至少需要 6 个字符"),
})
```

**步骤 6：添加更多测试用例**
```typescript
it("应该拒绝空密码", () => {
  const invalidData = {
    email: "user@example.com",
    password: "",
  }
  expect(() => loginSchema.parse(invalidData)).toThrow()
})
```

### TDD 的优势

1. **提高代码质量**：测试驱动开发确保代码可测试、可维护
2. **减少 Bug**：先写测试，提前发现潜在问题
3. **更好的设计**：测试驱动促使更好的代码结构
4. **文档作用**：测试用例本身就是最好的文档
5. **重构信心**：有测试保障，重构更安全

### TDD 最佳实践

1. ✅ **先写测试，再写代码**：严格遵循 Red-Green-Refactor 循环
2. ✅ **测试应该独立**：每个测试不依赖其他测试的状态
3. ✅ **测试应该快速**：使用 Mock 避免慢速操作（网络、文件 I/O）
4. ✅ **测试应该可读**：使用描述性命名和 AAA 模式
5. ✅ **测试应该全面**：覆盖正常情况、边界情况、异常情况
6. ✅ **保持测试通过**：重构时确保所有测试通过

### 本阶段的 TDD 实践

在本阶段的前端集成中，我们将严格遵循 TDD 流程：

1. **每个功能模块先写测试**（Red）
2. **运行测试确认失败**（Red）
3. **实现最小功能让测试通过**（Green）
4. **重构代码提高质量**（Refactor）
5. **添加更多测试用例完善功能**

每个步骤都有明确的验收标准，确保 TDD 流程的严格执行。

### 测试工具配置

#### Vitest 配置

确保项目已配置 Vitest，配置文件通常位于：
- `packages/utils/vitest.config.ts`
- `apps/web/vitest.config.ts`

**基本配置示例**：
```typescript
import { defineConfig } from "vitest/config"
import react from "@vitejs/plugin-react"
import path from "path"

export default defineConfig({
  plugins: [react()],
  test: {
    environment: "jsdom",
    globals: true,
    setupFiles: [".vitest-setup.ts"],
    coverage: {
      provider: "v8",
      reporter: ["text", "json", "html"],
      exclude: ["node_modules/", "dist/", "**/*.test.ts", "**/*.test.tsx"],
    },
  },
  resolve: {
    alias: {
      "@repo/utils": path.resolve(__dirname, "../../packages/utils/src"),
      "@repo/services": path.resolve(__dirname, "../../packages/services/src"),
    },
  },
})
```

#### 测试环境设置文件

创建 `.vitest-setup.ts` 文件（如果不存在）：
```typescript
import "@testing-library/jest-dom"
import { vi } from "vitest"

// Mock window.matchMedia
Object.defineProperty(window, "matchMedia", {
  writable: true,
  value: vi.fn().mockImplementation((query) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
})

// Mock sessionStorage
const sessionStorageMock = {
  getItem: vi.fn(),
  setItem: vi.fn(),
  removeItem: vi.fn(),
  clear: vi.fn(),
}
global.sessionStorage = sessionStorageMock as any
```

## 当前项目状态分析

### 已完成部分

1. **Token 存储工具** (`packages/utils/src/auth.ts`)：
   - ✅ 已实现内存存储变量 `accessTokenInMemory`
   - ✅ 已实现 `getAccessToken()`、`setAccessToken()` 方法
   - ✅ 已实现 `getRefreshToken()`、`setRefreshToken()` 方法
   - ✅ 已实现 `isTokenExpired()` 方法
   - ✅ 已实现 `clearTokens()` 方法

2. **API 服务基础** (`packages/services/src/api.service.base.ts`)：
   - ✅ 已实现请求拦截器，自动添加 `Authorization: Bearer {token}` Header
   - ✅ 已实现白名单机制（登录、注册、刷新接口不需要 Token）

3. **认证服务** (`packages/services/src/auth.service.ts`)：
   - ✅ 已实现 `authLogin()`、`authRefresh()`、`authLogout()` 等方法

### 待完成部分

1. **Schema 修改** (`packages/schemas/src/auth/login.schema.ts`)：
   - ❌ 当前使用 `username` 字段，需要改为 `email`
   - ❌ 需要移除 `rememberMe` 字段（如果存在）

2. **注册 Schema** (`packages/schemas/src/auth/register.schema.ts`)：
   - ✅ Schema 已定义，包含 username、email、password、confirmPassword、phone 字段
   - ❌ 缺少测试文件（`register.schema.test.ts`）

3. **登录页面** (`apps/web/app/(all)/sign-in/page.tsx`)：
   - ❌ 当前只是静态页面，没有使用 React Hook Form
   - ❌ 没有表单验证逻辑
   - ❌ 没有实际的登录提交逻辑
   - ❌ 需要参考 `sign-up/page.tsx` 的实现方式

4. **注册页面** (`apps/web/app/(all)/sign-up/page.tsx`)：
   - ✅ 已实现 React Hook Form + Zod 验证
   - ✅ 已实现表单提交逻辑
   - ✅ 已实现错误处理
   - ❌ 缺少测试文件（`sign-up/page.test.tsx`）

5. **Token 刷新机制** (`packages/services/src/api.service.base.ts`)：
   - ❌ 没有刷新队列实现
   - ❌ 没有 Token 自动刷新逻辑（Token 即将过期时）
   - ❌ 没有响应拦截器处理 401 错误

6. **API 集成** (`packages/services/src/auth.service.ts`)：
   - ✅ `RegisterRequest` 接口已定义
   - ✅ `authRegister()` 函数已实现
   - ❌ `LoginRequest` 接口使用的是 `username`，需要改为 `email`
   - ✅ `LoginResponse` 接口已定义（OAuth 2.0 格式）
   - ❌ 缺少注册 API 服务的测试

### 注意事项

- **已移除"记住我"功能**：根据最新需求，已从计划中移除"记住我"功能，Token 统一使用 sessionStorage 存储
- **参考注册页面**：登录页面的实现可以参考 `apps/web/app/(all)/sign-up/page.tsx`，该页面已完整实现 React Hook Form + Zod 验证

## 5.1 Schema 修改

### 步骤 5.1.1：编写 Schema 测试（先写测试）

- 打开文件：`packages/schemas/src/auth/login.schema.test.ts`（新建）
- 编写测试用例：
  ```typescript
  import { describe, it, expect } from "vitest";
  import { loginSchema } from "./login.schema";

  describe("loginSchema", () => {
    it("应该接受有效的邮箱和密码", () => {
      const validData = {
        email: "user@example.com",
        password: "password123",
      };
      expect(() => loginSchema.parse(validData)).not.toThrow();
    });

    it("应该拒绝无效的邮箱格式", () => {
      const invalidData = {
        email: "invalid-email",
        password: "password123",
      };
      expect(() => loginSchema.parse(invalidData)).toThrow();
    });

    it("应该拒绝空密码", () => {
      const invalidData = {
        email: "user@example.com",
        password: "",
      };
      expect(() => loginSchema.parse(invalidData)).toThrow();
    });

    it("应该拒绝缺少 email 字段", () => {
      const invalidData = {
        password: "password123",
      };
      expect(() => loginSchema.parse(invalidData)).toThrow();
    });
  });
  ```
- **验收标准**：测试用例编写完成，运行测试应该失败（因为功能还未实现）

### 步骤 5.1.2：修改登录 Schema（实现功能）

- 打开文件：`packages/schemas/src/auth/login.schema.ts`
- 将 `username` 字段改为 `email`
- 使用 `emailSchema` 替代 `usernameSchema`
- 移除 `rememberMe` 字段（如果存在）
- **验收标准**：Schema 修改完成，类型定义正确，所有测试通过

## 5.2 Token 存储策略

### 步骤 5.2.1：更新 Token 存储工具测试（先写测试）

- 打开文件：`packages/utils/src/auth.test.ts`
- 更新现有测试，移除所有"记住我"相关的测试用例
- 添加/更新以下测试用例：

**getAccessToken 测试**：
- ✅ 应该从内存中获取 token（如果存在）
- ✅ 应该从 sessionStorage 获取 token（内存中没有时）
- ✅ 应该返回 null（当 token 不存在时）
- ✅ 应该优先返回内存中的 token

**setAccessToken 测试**：
- ✅ 应该将 token 保存到内存和 sessionStorage
- ✅ 应该覆盖已存在的 token

**getRefreshToken / setRefreshToken 测试**：
- ✅ 应该从 sessionStorage 获取 refresh token
- ✅ 应该将 refresh token 保存到 sessionStorage
- ✅ 应该返回 null（当 refresh token 不存在时）

**isTokenExpired 测试**：
- ✅ 应该返回 false（当 token 未过期时）
- ✅ 应该返回 true（当 token 已过期时）
- ✅ 应该返回 true（当 token 即将过期，剩余时间 < 60 秒时）

**clearTokens 测试**：
- ✅ 应该清除内存中的 token
- ✅ 应该清除 sessionStorage 中的 token
- ✅ 应该清除所有相关的存储项

**saveTokens 测试**：
- ✅ 应该保存 access token 和 refresh token
- ✅ 应该保存 token 过期时间
- ✅ 应该处理 OAuth 2.0 格式的响应

- **验收标准**：测试用例编写完成，运行测试应该失败（因为功能还未更新）

### 步骤 5.2.2：更新 Token 存储工具实现（实现功能）

- 打开文件：`packages/utils/src/auth.ts`
- 移除所有"记住我"相关逻辑：
  - 移除 `REMEMBER_ME_KEY` 常量
  - 移除 `getStorage()` 函数中的"记住我"判断
  - 移除 `setAccessToken()` 中的 `rememberMe` 参数和相关逻辑
  - 移除 `setRefreshToken()` 中的 `rememberMe` 参数
  - 移除 `setTokenExpires()` 中的 `rememberMe` 参数
  - 移除 `getRememberMe()` 函数（如果存在）
  - 更新 `saveTokens()` 函数，移除 `rememberMe` 参数
- 统一使用 sessionStorage 存储 Token：
  - `getAccessToken()`：优先从内存读取，内存没有时从 sessionStorage 读取
  - `setAccessToken()`：存储到内存和 sessionStorage
  - `getRefreshToken()` / `setRefreshToken()`：使用 sessionStorage
  - `setTokenExpires()`：使用 sessionStorage
- **验收标准**：Token 存储功能完整，所有单元测试通过

## 5.3 登录页面完善

### 步骤 5.3.1：编写登录页面组件测试（先写测试）

- 打开文件：`apps/web/app/(all)/sign-in/page.test.tsx`（新建）

- 安装测试依赖（如果未安装）：
  ```bash
  pnpm add -D @testing-library/react @testing-library/jest-dom @testing-library/user-event vitest
  ```

- 设置测试环境（在测试文件顶部）：
  ```typescript
  import { describe, it, expect, vi, beforeEach } from "vitest"
  import { render, screen, waitFor } from "@testing-library/react"
  import { userEvent } from "@testing-library/user-event"
  import "@testing-library/jest-dom"
  import SignInPage from "./page"
  
  // Mock API调用
  vi.mock("@repo/services", () => ({
    authLogin: vi.fn(),
  }))
  
  // Mock路由
  const mockNavigate = vi.fn()
  vi.mock("react-router", () => ({
    useNavigate: () => mockNavigate,
  }))
  
  // Mock Toast
  vi.mock("react-hot-toast", () => ({
    default: {
      success: vi.fn(),
      error: vi.fn(),
    },
  }))
  
  // Mock Token存储工具
  vi.mock("@repo/utils", async () => {
    const actual = await vi.importActual("@repo/utils")
    return {
      ...actual,
      saveTokens: vi.fn(),
      clearTokens: vi.fn(),
      getAccessToken: vi.fn(),
    }
  })
  
  // Mock错误处理工具
  vi.mock("@repo/utils", async () => {
    const actual = await vi.importActual("@repo/utils")
    return {
      ...actual,
      handleServerError: vi.fn(),
    }
  })
  ```

- 编写测试用例：

**表单渲染测试**：
- ✅ 应该渲染邮箱输入框
- ✅ 应该渲染密码输入框
- ✅ 应该渲染登录按钮
- ✅ 应该渲染"忘记密码"链接
- ✅ 应该渲染"立即注册"链接
- ✅ 应该初始化为空表单

**表单验证测试**：
- ✅ 应该显示邮箱格式错误（当输入无效邮箱时）
- ✅ 应该显示密码必填错误（当密码为空时）
- ✅ 应该在失去焦点时验证字段（onBlur 模式）
- ✅ 应该在输入有效数据后清除错误消息

**表单提交测试**：
- ✅ 应该调用 authLogin API（当表单有效时）
- ✅ 应该传递正确的参数（email 和 password）
- ✅ 应该保存 Token（登录成功后）
- ✅ 应该显示成功消息（使用 toast.success）
- ✅ 应该跳转到首页（登录成功后）
- ✅ 应该显示错误消息（登录失败时）
- ✅ 应该处理字段级错误（API 返回 errors 数组时）
- ✅ 应该处理表单级错误（API 返回通用错误时）
- ✅ 应该处理网络错误（网络请求失败时）
- ✅ 应该处理服务器错误（5xx 错误）
- ✅ 应该禁用提交按钮（提交中时）
- ✅ 应该显示加载状态（提交中时）

**用户交互测试**：
- ✅ 应该允许用户输入邮箱
- ✅ 应该允许用户输入密码
- ✅ 应该允许用户点击"取消"按钮返回首页
- ✅ 应该允许用户点击"立即注册"跳转到注册页
- ✅ 应该支持键盘导航（Tab键、Enter键）

**可访问性测试**：
- ✅ 应该为输入框提供正确的 label 和 id
- ✅ 应该为输入框和 label 正确关联（htmlFor 和 id）
- ✅ 应该在错误时设置 aria-invalid="true"
- ✅ 应该为错误消息提供 role="alert"
- ✅ 应该为错误消息提供 aria-describedby 关联
- ✅ 应该支持键盘导航（Tab键在字段间切换）
- ✅ 应该支持 Enter 键提交表单
- ✅ 应该为按钮提供适当的 aria-label（如果需要）

**状态管理测试**：
- ✅ 应该初始化为空表单
- ✅ 应该在提交后重置表单（成功时）
- ✅ 应该保持表单状态（失败时，不重置）

- **验收标准**：测试用例编写完成，运行测试应该失败（因为功能还未实现）

### 步骤 5.3.2：实现登录页面（实现功能）

- 打开文件：`apps/web/app/(all)/sign-in/page.tsx`
- 参考 `apps/web/app/(all)/sign-up/page.tsx` 的实现方式
- 使用 React Hook Form + Zod 实现表单验证：
  - 导入 `useForm`、`zodResolver`
  - 导入 `loginSchema`（使用 email 字段）
  - 配置 `mode: "onBlur"` 验证模式
- 实现表单字段：
  - 邮箱输入框（使用 `register("email")`）
  - 密码输入框（使用 `register("password")`，type="password"）
  - 错误提示显示（使用 `errors.email`、`errors.password`）
- 实现表单提交逻辑：
  - 调用 `authLogin()` API（传递 email 和 password）
  - 使用 `saveTokens()` 保存 Token（不需要 rememberMe 参数）
  - 使用 `handleServerError` 处理错误
  - 使用 `toast.success` 显示成功消息
  - 登录成功后跳转到首页或指定页面
- 实现 UI 交互：
  - "取消"按钮跳转到首页
  - "立即注册"按钮跳转到注册页
- **验收标准**：登录页面功能完整，UI 正常，表单验证正确，所有测试通过

## 5.4 注册功能完善

### 步骤 5.4.1：编写注册 Schema 测试（先写测试）

- 打开文件：`packages/schemas/src/auth/register.schema.test.ts`（新建）
- 编写测试用例：
  ```typescript
  import { describe, it, expect } from "vitest";
  import { registerSchema } from "./register.schema";

  describe("registerSchema", () => {
    it("应该接受有效的注册数据", () => {
      // Arrange: 准备测试数据
      const validData = {
        username: "testuser",
        email: "user@example.com",
        password: "password123",
        confirmPassword: "password123",
        phone: "13800138000",
      };
      
      // Act: 调用 Schema 验证
      const result = registerSchema.parse(validData);
      
      // Assert: 验证结果
      expect(result).toEqual(validData);
    });

    it("应该拒绝无效的邮箱格式", () => {
      // Arrange: 准备无效的邮箱数据
      const invalidData = {
        username: "testuser",
        email: "invalid-email",
        password: "password123",
        confirmPassword: "password123",
      };
      
      // Act & Assert: 验证抛出错误
      expect(() => registerSchema.parse(invalidData)).toThrow();
    });

    it("应该拒绝密码不一致", () => {
      // Arrange: 准备密码不一致的数据
      const invalidData = {
        username: "testuser",
        email: "user@example.com",
        password: "password123",
        confirmPassword: "password456",
      };
      
      // Act & Assert: 验证抛出错误
      expect(() => registerSchema.parse(invalidData)).toThrow();
    });

    it("应该拒绝空密码", () => {
      // Arrange: 准备空密码数据
      const invalidData = {
        username: "testuser",
        email: "user@example.com",
        password: "",
        confirmPassword: "",
      };
      
      // Act & Assert: 验证抛出错误
      expect(() => registerSchema.parse(invalidData)).toThrow();
    });

    it("应该拒绝缺少必填字段", () => {
      // Arrange: 准备缺少必填字段的数据
      const invalidData = {
        email: "user@example.com",
        password: "password123",
        confirmPassword: "password123",
      } as any;
      
      // Act & Assert: 验证抛出错误
      expect(() => registerSchema.parse(invalidData)).toThrow();
    });

    it("应该接受可选的手机号字段", () => {
      // Arrange: 准备不包含手机号的数据
      const validData = {
        username: "testuser",
        email: "user@example.com",
        password: "password123",
        confirmPassword: "password123",
      };
      
      // Act: 调用 Schema 验证
      const result = registerSchema.parse(validData);
      
      // Assert: 验证结果（phone 字段为可选）
      expect(result.email).toBe(validData.email);
      expect(result.password).toBe(validData.password);
    });

    it("应该验证手机号格式（如果提供）", () => {
      // Arrange: 准备无效手机号数据
      const invalidData = {
        username: "testuser",
        email: "user@example.com",
        password: "password123",
        confirmPassword: "password123",
        phone: "123", // 无效的手机号格式
      };
      
      // Act & Assert: 验证抛出错误
      expect(() => registerSchema.parse(invalidData)).toThrow();
    });
  });
  ```
- **验收标准**：测试用例编写完成，运行测试应该失败（因为功能还未完善）

### 步骤 5.4.2：完善注册 Schema（实现功能）

- 打开文件：`packages/schemas/src/auth/register.schema.ts`
- 确保 Schema 包含以下字段：
  - `username`：用户名（必填）
  - `email`：邮箱（必填，使用 `emailSchema`）
  - `password`：密码（必填，使用 `passwordSchema`）
  - `confirmPassword`：确认密码（必填）
  - `phone`：手机号（可选，使用 `phoneSchema`）
- 确保跨字段验证正确：
  - 使用 `.refine()` 验证 `password === confirmPassword`
  - 错误消息指向 `confirmPassword` 字段
- **验收标准**：Schema 定义完整，类型定义正确，所有测试通过

### 步骤 5.4.3：编写注册页面组件测试（先写测试）

- 打开文件：`apps/web/app/(all)/sign-up/page.test.tsx`（新建）

- 安装测试依赖（如果未安装）：
  ```bash
  pnpm add -D @testing-library/react @testing-library/jest-dom @testing-library/user-event vitest
  ```

- 设置测试环境（在测试文件顶部）：
  ```typescript
  import { render, screen, waitFor } from "@testing-library/react"
  import userEvent from "@testing-library/user-event"
  import { beforeEach, describe, expect, it, vi } from "vitest"
  import "@testing-library/jest-dom/vitest"
  import SignUpPage from "./page"
  
  // Mock API调用
  vi.mock("@repo/services", () => ({
    authRegister: vi.fn(),
  }))
  
  // Mock路由
  const mockNavigateFn = vi.fn()
  vi.mock("react-router", () => ({
    useNavigate: () => mockNavigateFn,
  }))
  
  // Mock Toast
  vi.mock("@repo/propel", () => ({
    toast: {
      success: vi.fn(),
      error: vi.fn(),
    },
    toastError: vi.fn(),
  }))
  
  // Mock错误处理工具
  vi.mock("@repo/utils", async () => {
    const actual = await vi.importActual("@repo/utils")
    return {
      ...actual,
      handleServerError: vi.fn(),
    }
  })
  
  import { toast } from "@repo/propel"
  import { authRegister } from "@repo/services"
  import { toastError } from "@repo/propel"
  
  const mockAuthRegister = vi.mocked(authRegister)
  const mockToastSuccess = vi.mocked(toast.success)
  const mockToastError = vi.mocked(toastError)
  ```

- 编写测试用例：

**表单渲染测试**：
- ✅ 应该渲染用户名输入框
- ✅ 应该渲染邮箱输入框
- ✅ 应该渲染密码输入框
- ✅ 应该渲染确认密码输入框
- ✅ 应该渲染手机号输入框（可选）
- ✅ 应该渲染注册按钮
- ✅ 应该渲染"立即登录"链接
- ✅ 应该初始化为空表单

**表单验证测试**：
- ✅ 应该显示邮箱格式错误（当输入无效邮箱时）
- ✅ 应该显示密码必填错误（当密码为空时）
- ✅ 应该显示密码不一致错误（当两次密码不一致时）
- ✅ 应该显示用户名必填错误（当用户名为空时）
- ✅ 应该在失去焦点时验证字段（onBlur 模式）
- ✅ 应该在输入有效数据后清除错误消息
- ✅ 应该验证手机号格式（如果提供）

**表单提交测试**：
- ✅ 应该调用 authRegister API（当表单有效时）
- ✅ 应该传递正确的参数（email、password 等）
- ✅ 应该显示成功消息（使用 toast.success）
- ✅ 应该跳转到登录页（注册成功后）
- ✅ 应该显示错误消息（注册失败时）
- ✅ 应该处理字段级错误（API 返回 errors 数组时）
- ✅ 应该处理表单级错误（API 返回通用错误时）
- ✅ 应该处理网络错误（网络请求失败时）
- ✅ 应该处理服务器错误（5xx 错误）
- ✅ 应该禁用提交按钮（提交中时）
- ✅ 应该显示加载状态（提交中时）

**用户交互测试**：
- ✅ 应该允许用户输入用户名
- ✅ 应该允许用户输入邮箱
- ✅ 应该允许用户输入密码
- ✅ 应该允许用户输入确认密码
- ✅ 应该允许用户输入手机号（可选）
- ✅ 应该允许用户切换密码显示/隐藏
- ✅ 应该允许用户点击"取消"按钮返回首页
- ✅ 应该允许用户点击"立即登录"跳转到登录页
- ✅ 应该支持键盘导航（Tab键、Enter键）

**可访问性测试**：
- ✅ 应该为输入框提供正确的 label 和 id
- ✅ 应该为输入框和 label 正确关联（htmlFor 和 id）
- ✅ 应该在错误时设置 aria-invalid="true"
- ✅ 应该为错误消息提供 role="alert"
- ✅ 应该为错误消息提供 aria-describedby 关联
- ✅ 应该支持键盘导航（Tab键在字段间切换）
- ✅ 应该支持 Enter 键提交表单
- ✅ 应该为密码显示/隐藏按钮提供 aria-label

**状态管理测试**：
- ✅ 应该初始化为空表单
- ✅ 应该在提交后重置表单（成功时）
- ✅ 应该保持表单状态（失败时，不重置）

- **验收标准**：测试用例编写完成，运行测试应该失败（因为功能还未实现）

### 步骤 5.4.4：完善注册页面（实现功能）

- 打开文件：`apps/web/app/(all)/sign-up/page.tsx`
- 确保使用 React Hook Form + Zod 实现表单验证：
  - 导入 `useForm`、`zodResolver`
  - 导入 `registerSchema`
  - 配置 `mode: "onBlur"` 验证模式
- 实现表单字段：
  - 用户名输入框（使用 `register("username")`）
  - 邮箱输入框（使用 `register("email")`）
  - 密码输入框（使用 `register("password")`，type="password"，支持显示/隐藏）
  - 确认密码输入框（使用 `register("confirmPassword")`，支持显示/隐藏）
  - 手机号输入框（使用 `register("phone")`，可选）
  - 错误提示显示（使用 `errors.username`、`errors.email` 等）
- 实现表单提交逻辑：
  - 调用 `authRegister()` API（传递 email、password 等）
  - 使用 `toastError` 处理错误（使用 `handleServerError`）
  - 使用 `toast.success` 显示成功消息
  - 注册成功后跳转到登录页
- 实现 UI 交互：
  - "取消"按钮跳转到首页
  - "立即登录"按钮跳转到登录页
  - 密码显示/隐藏切换功能
- **验收标准**：注册页面功能完整，UI 正常，表单验证正确，所有测试通过

### 步骤 5.4.5：编写注册 API 服务测试（先写测试）

- 打开文件：`packages/services/src/auth.service.test.ts`（如果已存在，添加注册相关测试）

- 编写测试用例：

**RegisterRequest 接口测试**：
- ✅ 应该定义 RegisterRequest 接口
- ✅ 应该包含 email、password 等字段
- ✅ email 和 password 应该是必填字段
- ✅ username 和 phone 应该是可选字段

**authRegister 测试**：
- ✅ 应该调用正确的 API 端点（`/auth/register`）
- ✅ 应该传递 email 和 password 参数
- ✅ 应该传递可选的 username 和 phone 参数
- ✅ 应该返回 `Promise<AxiosResponse<ApiResponseBase<LoginResponse>>>` 类型
- ✅ 应该处理 API 错误
- ✅ 应该使用 POST 方法

- **验收标准**：测试用例编写完成，运行测试应该失败（因为功能还未完善）

### 步骤 5.4.6：完善注册 API 服务（实现功能）

- 打开文件：`packages/services/src/auth.service.ts`
- 确保 `RegisterRequest` 接口定义正确：
  ```typescript
  export interface RegisterRequest {
    username?: string;
    email: string;
    password: string;
    phone?: string;
  }
  ```
- 确保 `authRegister()` 函数实现正确：
  - 调用 `POST /auth/register` API
  - 传递 `RegisterRequest` 类型的数据
  - 返回 `Promise<AxiosResponse<ApiResponseBase<LoginResponse>>>`
  - 注册成功后返回 `LoginResponse`（包含 Token）
- **验收标准**：API 调用正确，类型定义完整，所有测试通过

## 5.5 Token 刷新机制

### 步骤 5.5.1：编写刷新队列测试（先写测试）

- 打开文件：`packages/services/src/api.service.base.test.ts`（新建）

- 设置测试环境（在测试文件顶部）：
  ```typescript
  import { describe, it, expect, vi, beforeEach } from "vitest"
  import axios from "axios"
  
  // Mock Token存储工具
  vi.mock("@repo/utils", () => ({
    getAccessToken: vi.fn(),
    getRefreshToken: vi.fn(),
    setAccessToken: vi.fn(),
    setRefreshToken: vi.fn(),
    setTokenExpires: vi.fn(),
    isTokenExpired: vi.fn(),
    clearTokens: vi.fn(),
    saveTokens: vi.fn(),
  }))
  
  // Mock auth服务
  vi.mock("./auth.service", () => ({
    authRefresh: vi.fn(),
  }))
  
  beforeEach(() => {
    vi.clearAllMocks()
  })
  ```

- 编写刷新队列相关测试：
  ```typescript
  describe("Token 刷新队列", () => {
    it("应该将请求加入刷新队列", () => {
      // Arrange: 设置刷新进行中
      // Act: 调用 subscribeTokenRefresh
      // Assert: 验证回调函数被加入队列
    });

    it("应该通知队列中的所有请求", () => {
      // Arrange: 设置队列中有多个回调
      // Act: 调用 onTokenRefreshed
      // Assert: 验证所有回调都被调用，并传入新token
    });

    it("应该防止并发刷新", () => {
      // Arrange: 设置刷新进行中
      // Act: 同时触发多个刷新请求
      // Assert: 验证只有一次刷新API调用，其他请求加入队列
    });

    it("应该在刷新完成后清空队列", () => {
      // Arrange: 设置队列中有回调
      // Act: 调用 onTokenRefreshed
      // Assert: 验证队列被清空
    });

    it("应该处理刷新失败时的队列", () => {
      // Arrange: 设置刷新失败
      // Act: 刷新失败
      // Assert: 验证队列被清空，错误被正确处理
    });
  });
  ```

- **验收标准**：测试用例编写完成，运行测试应该失败（因为功能还未实现）

### 步骤 5.5.2：编写刷新 Token 函数测试（先写测试）

- 在 `api.service.base.test.ts` 中添加测试：
  ```typescript
  describe("refreshToken", () => {
    it("应该调用刷新 API", () => {
      // Arrange: Mock getRefreshToken 返回 refresh token
      // Act: 调用 refreshToken
      // Assert: 验证 authRefresh 被调用，传递正确的 refresh token
    });

    it("应该保存新的 Token", () => {
      // Arrange: Mock authRefresh 返回新 token
      // Act: 调用 refreshToken
      // Assert: 验证 saveTokens 被调用，传递正确的 token 数据
    });

    it("应该通知刷新队列", () => {
      // Arrange: 设置队列中有回调
      // Act: 调用 refreshToken
      // Assert: 验证 onTokenRefreshed 被调用
    });

    it("应该处理刷新失败", () => {
      // Arrange: Mock authRefresh 抛出错误
      // Act: 调用 refreshToken
      // Assert: 验证错误被正确处理，队列被清空
    });

    it("应该在没有 refresh token 时抛出错误", () => {
      // Arrange: Mock getRefreshToken 返回 null
      // Act: 调用 refreshToken
      // Assert: 验证抛出错误
    });

    it("应该设置 isRefreshing 标志", () => {
      // Arrange: 设置初始状态
      // Act: 调用 refreshToken
      // Assert: 验证 isRefreshing 在刷新过程中为 true，完成后为 false
    });
  });
  ```
- **验收标准**：测试用例编写完成，运行测试应该失败

### 步骤 5.5.3：实现刷新队列和刷新 Token 函数（实现功能）

- 打开文件：`packages/services/src/api.service.base.ts`
- 添加刷新队列变量：
  ```typescript
  let isRefreshing = false
  let refreshSubscribers: Array<(token: string) => void> = []
  ```
- 实现 `subscribeTokenRefresh()` 方法（加入队列）
- 实现 `onTokenRefreshed()` 方法（通知队列）
- 实现 `refreshToken()` 函数：
  - 获取 Refresh Token
  - 调用 `POST /api/v1/auth/refresh` API（不走拦截器，避免循环）
  - 保存新 Token
  - 通知刷新队列
- **验收标准**：Token 刷新功能正常，所有测试通过

### 步骤 5.5.4：编写请求拦截器测试（先写测试）

- 在 `api.service.base.test.ts` 中添加测试：
  ```typescript
  describe("请求拦截器", () => {
    beforeEach(() => {
      // 重置所有 Mock
      vi.clearAllMocks()
    })

    it("应该自动添加 Authorization Header", () => {
      // Arrange: Mock getAccessToken 返回 token
      // Act: 发送请求
      // Assert: 验证请求头包含 Authorization: Bearer {token}
    });

    it("应该在 Token 即将过期时自动刷新", () => {
      // Arrange: Mock isTokenExpired 返回 true（剩余时间 < 5分钟）
      // Act: 发送请求
      // Assert: 验证 refreshToken 被调用
    });

    it("应该等待刷新完成后再发送请求", () => {
      // Arrange: 设置刷新进行中，请求加入队列
      // Act: 发送请求
      // Assert: 验证请求等待刷新完成，使用新 token
    });

    it("应该跳过白名单路径的 Token 添加", () => {
      // Arrange: 设置请求路径为白名单路径（如 /api/v1/auth/login）
      // Act: 发送请求
      // Assert: 验证请求头不包含 Authorization
    });

    it("应该在 Token 不存在时跳过添加 Header", () => {
      // Arrange: Mock getAccessToken 返回 null
      // Act: 发送请求
      // Assert: 验证请求头不包含 Authorization
    });

    it("应该处理刷新失败的情况", () => {
      // Arrange: Mock refreshToken 抛出错误
      // Act: 发送请求（触发刷新）
      // Assert: 验证错误被正确处理，请求被拒绝
    });
  });
  ```
- **验收标准**：测试用例编写完成，运行测试应该失败

### 步骤 5.5.5：实现请求拦截器（实现功能）

- 在 `api.service.base.ts` 中更新请求拦截器
- 自动添加 `Authorization: Bearer {token}` Header
- Token 即将过期时（剩余时间 < 5 分钟）自动刷新
- 刷新队列处理（等待刷新完成）
- **验收标准**：请求拦截器功能正常，自动刷新生效，所有测试通过

### 步骤 5.5.6：编写响应拦截器测试（先写测试）

- 在 `api.service.base.test.ts` 中添加测试：
  ```typescript
  describe("响应拦截器", () => {
    beforeEach(() => {
      // 重置所有 Mock
      vi.clearAllMocks()
    })

    it("应该处理 401 错误并刷新 Token", () => {
      // Arrange: Mock 响应返回 401 错误
      // Act: 处理响应
      // Assert: 验证 refreshToken 被调用
    });

    it("应该在刷新成功后重试原请求", () => {
      // Arrange: Mock 401 错误，Mock refreshToken 成功
      // Act: 处理响应
      // Assert: 验证原请求被重试，使用新 token
    });

    it("应该在刷新失败时清除 Token 并跳转登录页", () => {
      // Arrange: Mock 401 错误，Mock refreshToken 失败
      // Act: 处理响应
      // Assert: 验证 clearTokens 被调用，验证跳转登录页
    });

    it("应该自动保存登录响应的 Token", () => {
      // Arrange: Mock 登录响应（包含 token）
      // Act: 处理响应
      // Assert: 验证 saveTokens 被调用，传递正确的 token 数据
    });

    it("应该处理网络错误", () => {
      // Arrange: Mock 网络错误（如 ECONNABORTED）
      // Act: 处理响应
      // Assert: 验证错误被正确处理，不触发刷新
    });

    it("应该处理服务器错误（5xx）", () => {
      // Arrange: Mock 响应返回 500 错误
      // Act: 处理响应
      // Assert: 验证错误被正确处理，不触发刷新
    });

    it("应该处理业务错误（非 401）", () => {
      // Arrange: Mock 响应返回业务错误（如 400、403）
      // Act: 处理响应
      // Assert: 验证错误被正确处理，不触发刷新
    });

    it("应该处理刷新队列中的多个请求", () => {
      // Arrange: 设置多个请求等待刷新
      // Act: 刷新成功后处理响应
      // Assert: 验证所有等待的请求都被重试
    });
  });
  ```
- **验收标准**：测试用例编写完成，运行测试应该失败

### 步骤 5.5.7：实现响应拦截器（实现功能）

- 在 `api.service.base.ts` 中添加响应拦截器
- 处理 401 错误：
  - 尝试刷新 Token
  - 刷新成功后重试原请求
  - 刷新失败时清除 Token 并跳转登录页
- 自动保存登录响应的 Token
- Token 刷新后更新请求队列
- **验收标准**：响应拦截器功能正常，401 重试机制生效，所有测试通过

## 5.6 API 集成

### 步骤 5.6.1：编写 auth.service 测试（先写测试）

- 打开文件：`packages/services/src/auth.service.test.ts`（新建）
- 编写测试用例：

**LoginResponse 接口测试**：
- ✅ 应该定义 LoginResponse 接口（OAuth 2.0 格式）
- ✅ 应该包含 accessToken、refreshToken、expiresIn 等字段

**authLogin 测试**：
- ✅ 应该调用正确的 API 端点
- ✅ 应该传递 email 和 password 参数
- ✅ 应该返回 LoginResponse 类型
- ✅ 应该处理 API 错误

**authRefresh 测试**：
- ✅ 应该调用刷新 API
- ✅ 应该传递 refreshToken
- ✅ 应该返回新的 Token

**authLogout 测试**：
- ✅ 应该调用登出 API
- ✅ 应该清除 Token

- **验收标准**：测试用例编写完成，运行测试应该失败（因为功能还未实现）

### 步骤 5.6.2：完善 auth.service.ts（实现功能）

- 打开文件：`packages/services/src/auth.service.ts`
- 定义 `LoginResponse` 接口（遵循 OAuth 2.0 格式）：
  ```typescript
  export interface LoginResponse {
    accessToken: string;
    refreshToken: string;
    expiresIn: number;
    tokenType?: string;
  }
  ```
- 修改 `LoginRequest` 接口：
  - 将 `username` 改为 `email`
  - 移除 `rememberMe` 字段（如果存在）
- 修改 `authLogin()` 函数：
  - 返回类型为 `Promise<AxiosResponse<ApiResponseBase<LoginResponse>>>`
  - 处理响应数据
- **验收标准**：API 调用正确，类型定义完整，所有测试通过

### 步骤 5.6.3：端到端测试（完整流程测试）

#### 集成测试

**注册流程集成测试**：
- ✅ 填写表单 → 提交 → 验证错误处理 → 验证成功跳转
- ✅ 测试 Schema 验证与表单组件的集成
- ✅ 测试 API 调用与错误处理的集成
- ✅ 测试密码确认验证（跨字段验证）
- ✅ 测试可选字段（username、phone）的处理
- ✅ 测试注册成功后跳转到登录页

**登录流程集成测试**：
- ✅ 填写表单 → 提交 → 验证 Token 存储 → 验证跳转
- ✅ 测试表单验证与 API 调用的集成
- ✅ 测试 Token 存储与页面跳转的集成

**Token 刷新集成测试**：
- ✅ 等待 Token 过期 → 验证自动刷新 → 验证请求重试
- ✅ 测试请求拦截器与刷新机制的集成
- ✅ 测试响应拦截器与刷新机制的集成
- ✅ 测试刷新队列与请求重试的集成

**登出流程集成测试**：
- ✅ 点击登出 → 验证 Token 清除 → 验证跳转登录页
- ✅ 测试 API 调用与 Token 清除的集成

#### E2E 测试（可选，使用 Playwright 或 Cypress）

**完整用户流程测试**：
- ✅ 用户注册 → 登录 → 访问受保护页面 → 登出
- ✅ 用户登录 → Token 过期 → 自动刷新 → 继续访问
- ✅ 用户登录 → 刷新失败 → 跳转登录页

**验收标准**：
- ✅ 所有集成测试通过
- ✅ 所有 E2E 测试通过（如果实施）
- ✅ 完整流程测试通过，所有功能正常

## 相关文件

### 源代码文件
- `packages/schemas/src/auth/login.schema.ts` - 登录 Schema
- `packages/schemas/src/auth/register.schema.ts` - 注册 Schema
- `packages/utils/src/auth.ts` - Token 存储工具
- `apps/web/app/(all)/sign-in/page.tsx` - 登录页面
- `apps/web/app/(all)/sign-up/page.tsx` - 注册页面
- `packages/services/src/api.service.base.ts` - API 基础服务（拦截器）
- `packages/services/src/auth.service.ts` - 认证服务

### 测试文件
- `packages/schemas/src/auth/login.schema.test.ts` - 登录 Schema 测试
- `packages/schemas/src/auth/register.schema.test.ts` - 注册 Schema 测试
- `packages/utils/src/auth.test.ts` - Token 存储工具测试
- `apps/web/app/(all)/sign-in/page.test.tsx` - 登录页面组件测试
- `apps/web/app/(all)/sign-up/page.test.tsx` - 注册页面组件测试
- `packages/services/src/api.service.base.test.ts` - API 基础服务测试
- `packages/services/src/auth.service.test.ts` - 认证服务测试

## 依赖关系

- **依赖第二阶段**：需要后端 API 已实现
- **依赖第三阶段**：需要 Token 刷新接口已实现

## 验收标准总结

### 测试驱动开发（TDD）流程
- ✅ 每个功能模块都先编写测试用例
- ✅ 测试用例编写完成后运行测试（应该失败）
- ✅ 实现功能代码使测试通过
- ✅ 所有测试通过后进入下一个模块

### 功能验收标准
- ✅ Schema 修改完成，类型定义正确，测试通过
  - ✅ 登录 Schema 修改完成，测试通过
  - ✅ 注册 Schema 完善完成，测试通过
- ✅ Token 存储功能完整，单元测试通过（覆盖率 80%+）
- ✅ 登录页面功能完整，UI 正常，表单验证正确，组件测试通过
- ✅ 注册页面功能完整，UI 正常，表单验证正确，组件测试通过
- ✅ Token 刷新功能正常，单元测试通过
- ✅ 请求拦截器功能正常，自动刷新生效，测试通过
- ✅ 响应拦截器功能正常，401 重试机制生效，测试通过
- ✅ API 调用正确，类型定义完整，测试通过
  - ✅ 登录 API 集成完成，测试通过
  - ✅ 注册 API 集成完成，测试通过
- ✅ 完整流程测试通过，所有功能正常

### 测试覆盖率要求
- **单元测试覆盖率**：≥ 80%
- **关键功能覆盖率**：100%（Token 存储、刷新机制、错误处理）
- **UI 组件测试覆盖率**：≥ 80%（关键 UI 组件）
- **工具函数覆盖率**：≥ 90%
- **业务逻辑覆盖率**：≥ 70%

### 测试质量要求
- ✅ 所有测试用例使用 AAA 模式（Arrange-Act-Assert）
- ✅ 所有测试用例使用描述性命名（中文）
- ✅ 所有测试文件与源文件 co-located（放在同一目录）
- ✅ 所有测试独立，不依赖其他测试的状态
- ✅ 使用 Mock 隔离外部依赖（API、浏览器 API）
- ✅ UI 测试使用语义化查询（getByRole、getByLabelText 等）
- ✅ UI 测试使用 userEvent 模拟真实用户操作
- ✅ 可访问性测试覆盖 ARIA 属性、键盘导航、屏幕阅读器支持

### 运行测试命令
```bash
# 运行所有测试
pnpm test

# 运行测试并查看覆盖率
pnpm test:coverage

# 监听模式运行测试
pnpm test:watch

# 运行特定文件的测试
pnpm test auth.test.ts

# 运行特定包的测试
pnpm test --filter @repo/utils
```
