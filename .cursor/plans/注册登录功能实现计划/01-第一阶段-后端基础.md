# 第一阶段：后端基础（核心功能）

**预计时间**：3-5 天

**前置依赖**：无

**目标**：完成后端基础架构搭建，包括数据库实体、安全配置、JWT 服务和 DTO 定义。

---

## 1.1 数据库和实体准备

### 步骤 1.1.1：修改 UserEntity

**文件**：`services/user-service/src/main/java/com/example/user/entity/UserEntity.java`

**操作**：
- 打开文件
- 添加 `password` 字段：`private String password;`
- 添加 `@Column(name = "password", nullable = false)` 注解
- 确保密码字段不在 `toDTO()` 方法中返回

**伪代码示例**：

```java
@Entity
@Table(name = "users")
public class UserEntity {
    // ... 现有字段 ...
    
    /**
     * 用户密码（BCrypt 加密后的哈希值）
     * 不在 DTO 转换中返回，确保安全
     */
    @Column(name = "password", nullable = false, length = 255)
    private String password;
    
    // Getter 和 Setter
    public String getPassword() {
        return password;
    }
    
    public void setPassword(String password) {
        this.password = password;
    }
    
    /**
     * 转换为 DTO（不包含密码字段）
     */
    public UserDTO toDTO() {
        UserDTO dto = new UserDTO();
        dto.setId(this.id);
        dto.setEmail(this.email);
        dto.setUsername(this.username);
        // 注意：不设置 password 字段
        return dto;
    }
}
```

**验收标准**：
- ✅ 编译通过
- ✅ 密码字段正确映射到数据库
- ✅ `toDTO()` 方法不返回密码
- ✅ 单元测试（推荐）：`UserEntityTest` 覆盖 `toDTO()` 不包含 `password`（防止敏感字段泄露）

---

### 步骤 1.1.2：数据库迁移

**文件**：`services/user-service/src/main/resources/db/migration/V2__add_password_to_users.sql`（新建）

**操作**：
- 创建 Flyway 迁移脚本
- 或配置 JPA 自动更新：`spring.jpa.hibernate.ddl-auto=update`
- 执行迁移，验证数据库表结构

**伪代码示例（Flyway 迁移脚本）**：

```sql
-- V2__add_password_to_users.sql
-- 添加密码字段到 users 表

ALTER TABLE users 
ADD COLUMN password VARCHAR(255) NOT NULL DEFAULT '';

-- 为现有用户设置临时密码（需要后续强制重置）
-- UPDATE users SET password = '$2a$12$temp_hash_placeholder' WHERE password = '';

-- 添加索引（如果需要）
-- CREATE INDEX idx_users_email ON users(email);
```

**配置示例（JPA 自动更新）**：

```yaml
# application.yml
spring:
  jpa:
    hibernate:
      ddl-auto: update  # 开发环境使用，生产环境应使用 validate
    show-sql: true
    properties:
      hibernate:
        format_sql: true
```

**验证 SQL**：

```sql
-- 验证表结构
DESCRIBE users;

-- 验证约束
SELECT 
    COLUMN_NAME, 
    IS_NULLABLE, 
    DATA_TYPE, 
    COLUMN_DEFAULT
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_NAME = 'users' AND COLUMN_NAME = 'password';
```

**验收标准**：
- ✅ 数据库表包含 password 字段
- ✅ 非空约束生效
- ✅ 现有数据不受影响
- ✅（可选增强）迁移自动化验证：使用 Testcontainers（PostgreSQL）或 H2 + Flyway 启动后，校验 schema 已包含 `password` 且迁移可重复执行

---

## 1.2 安全配置

### 步骤 1.2.1：创建 SecurityConfig

**文件**：`services/user-service/src/main/java/com/example/user/config/SecurityConfig.java`（新建）

**操作**：
- 创建文件
- 添加 `@Configuration` 注解
- 创建 `PasswordEncoder` Bean

**伪代码示例**：

```java
package com.example.user.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

/**
 * 安全配置类
 * 配置密码加密器和其他安全相关 Bean
 */
@Configuration
public class SecurityConfig {
    
    /**
     * 密码加密器 Bean
     * 使用 BCrypt 算法，成本因子 12（推荐值）
     * 
     * BCrypt 成本因子说明：
     * - 10: 快速，适合开发环境
     * - 12: 推荐值，平衡安全性和性能
     * - 15+: 高安全性，但性能较慢
     */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(12);
    }
    
    /**
     * 使用示例：
     * 
     * // 加密密码
     * String rawPassword = "userPassword123";
     * String encodedPassword = passwordEncoder.encode(rawPassword);
     * 
     * // 验证密码
     * boolean matches = passwordEncoder.matches(rawPassword, encodedPassword);
     */
}
```

**测试验证代码**：

```java
// 在测试类中验证 Bean 创建
@SpringBootTest
class SecurityConfigTest {
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Test
    void testPasswordEncoder() {
        assertNotNull(passwordEncoder);
        String password = "testPassword123";
        String encoded = passwordEncoder.encode(password);
        assertTrue(passwordEncoder.matches(password, encoded));
    }
}
```

**验收标准**：
- ✅ Spring 容器成功创建 PasswordEncoder Bean
- ✅ 密码加密和验证功能正常
- ✅ 单元测试（推荐）：`SecurityConfigTest` 使用 `@SpringBootTest` 注入 `PasswordEncoder` 并验证 `matches()`

---

### 步骤 1.2.2：添加依赖

**文件**：`services/user-service/pom.xml`

**操作**：
- 打开文件
- 添加依赖
- 执行 `mvn clean install` 验证依赖

**依赖配置**：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

**验收标准**：
- ✅ 依赖下载成功
- ✅ 项目编译通过

---

## 1.3 JWT 服务实现

### 步骤 1.3.1：生成 RSA 密钥对

**操作**：
- 使用 OpenSSL 生成私钥：`openssl genrsa -out private.pem 2048`
- 提取公钥：`openssl rsa -in private.pem -pubout -out public.pem`
- 将密钥文件放在：`services/user-service/src/main/resources/keys/`

**命令示例**：

```bash
# 生成私钥（2048 位）
openssl genrsa -out private.pem 2048

# 从私钥提取公钥
openssl rsa -in private.pem -pubout -out public.pem

# 将密钥文件放在 resources/keys/ 目录下
mkdir -p services/user-service/src/main/resources/keys
mv private.pem services/user-service/src/main/resources/keys/
mv public.pem services/user-service/src/main/resources/keys/
```

**验收标准**：
- ✅ 密钥文件存在
- ✅ 格式正确（PEM 格式）

---

### 步骤 1.3.2：配置 JWT 属性

**文件**：`services/user-service/src/main/resources/application.yml`

**操作**：
- 打开文件
- 添加 JWT 配置

**配置示例**：

```yaml
jwt:
  # 签名算法：RS256（非对称加密，推荐用于微服务架构）
  algorithm: RS256
  
  # RS256 密钥对路径
  private-key-path: classpath:keys/private.pem
  public-key-path: classpath:keys/public.pem
  
  # Token 有效期（秒）
  access-token-expiration: 1800      # 30 分钟
  refresh-token-expiration: 604800   # 7 天
  remember-me-expiration: 7776000   # 90 天
  
  # 签发者和受众（可选）
  issuer: ${JWT_ISSUER:https://auth.example.com}
  audience: ${JWT_AUDIENCE:api.example.com}
```

**验收标准**：
- ✅ 配置加载成功
- ✅ 无配置错误

---

### 步骤 1.3.3：创建 JwtService

**文件**：`services/user-service/src/main/java/com/example/user/service/JwtService.java`（新建）

**操作**：
- 创建文件
- 实现 `generateAccessToken()` 方法（RS256 算法）
- 实现 `generateRefreshToken()` 方法
- 实现 `parseToken()` 方法（Token 验证）
- 添加单元测试：`JwtServiceTest.java`

**伪代码示例（JwtService）**：

```java
package com.example.user.service;

import io.jsonwebtoken.*;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Service;

import java.nio.file.Files;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
public class JwtService {
    
    @Value("${jwt.private-key-path}")
    private Resource privateKeyResource;
    
    @Value("${jwt.public-key-path}")
    private Resource publicKeyResource;
    
    @Value("${jwt.access-token-expiration:1800}")
    private long accessTokenExpiration;
    
    @Value("${jwt.refresh-token-expiration:604800}")
    private long refreshTokenExpiration;
    
    @Value("${jwt.issuer:https://auth.example.com}")
    private String issuer;
    
    @Value("${jwt.audience:api.example.com}")
    private String audience;
    
    /**
     * 生成 Access Token
     * 
     * @param userId 用户ID
     * @param username 用户名
     * @param roles 用户角色列表
     * @return Access Token 字符串
     */
    public String generateAccessToken(String userId, String username, List<String> roles) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + accessTokenExpiration * 1000);
        
        Map<String, Object> claims = new HashMap<>();
        claims.put("username", username);
        claims.put("roles", roles);
        claims.put("type", "access");
        
        return Jwts.builder()
                .setClaims(claims)
                .setSubject(userId)  // sub claim
                .setIssuer(issuer)   // iss claim
                .setAudience(audience) // aud claim
                .setIssuedAt(now)     // iat claim
                .setExpiration(expiryDate) // exp claim
                .signWith(getPrivateKey(), SignatureAlgorithm.RS256)
                .compact();
    }
    
    /**
     * 生成 Refresh Token
     * 
     * @param userId 用户ID
     * @param deviceId 设备ID（可选）
     * @return Refresh Token 字符串
     */
    public String generateRefreshToken(String userId, String deviceId) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + refreshTokenExpiration * 1000);
        
        Map<String, Object> claims = new HashMap<>();
        claims.put("type", "refresh");
        if (deviceId != null) {
            claims.put("deviceId", deviceId);
        }
        
        return Jwts.builder()
                .setClaims(claims)
                .setSubject(userId)
                .setIssuer(issuer)
                .setAudience(audience)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(getPrivateKey(), SignatureAlgorithm.RS256)
                .compact();
    }
    
    /**
     * 解析和验证 Token
     * 
     * @param token JWT Token 字符串
     * @return Claims 对象，包含 Token 中的所有声明
     * @throws ExpiredJwtException Token 已过期
     * @throws JwtException Token 无效
     */
    public Claims parseToken(String token) {
        try {
            return Jwts.parserBuilder()
                    .setSigningKey(getPublicKey())
                    .requireIssuer(issuer)
                    .requireAudience(audience)
                    .build()
                    .parseClaimsJws(token)
                    .getBody();
        } catch (ExpiredJwtException e) {
            throw new ExpiredJwtException(e.getHeader(), e.getClaims(), "Token 已过期");
        } catch (JwtException e) {
            throw new JwtException("无效的 Token: " + e.getMessage());
        }
    }
    
    /**
     * 从资源文件加载私钥
     */
    private PrivateKey getPrivateKey() {
        try {
            byte[] keyBytes = Files.readAllBytes(privateKeyResource.getFile().toPath());
            PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
            KeyFactory kf = KeyFactory.getInstance("RSA");
            return kf.generatePrivate(spec);
        } catch (Exception e) {
            throw new RuntimeException("加载私钥失败", e);
        }
    }
    
    /**
     * 从资源文件加载公钥
     */
    private PublicKey getPublicKey() {
        try {
            byte[] keyBytes = Files.readAllBytes(publicKeyResource.getFile().toPath());
            X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);
            KeyFactory kf = KeyFactory.getInstance("RSA");
            return kf.generatePublic(spec);
        } catch (Exception e) {
            throw new RuntimeException("加载公钥失败", e);
        }
    }
    
    /**
     * 检查 Token 是否即将过期（剩余时间 < 5 分钟）
     */
    public boolean isTokenExpiringSoon(String token) {
        try {
            Claims claims = parseToken(token);
            Date expiration = claims.getExpiration();
            long remainingTime = expiration.getTime() - System.currentTimeMillis();
            return remainingTime < 5 * 60 * 1000; // 5 分钟
        } catch (Exception e) {
            return true; // 如果解析失败，认为已过期
        }
    }
}
```

**实现注意（重要）**：
- 伪代码中使用 `privateKeyResource.getFile()` / `publicKeyResource.getFile()` 读取 classpath 文件，在打包成 jar 或容器环境中可能失效。
- 推荐实现方式：使用 `privateKeyResource.getInputStream()` 读取；或在测试里用 `@TestPropertySource` 指向临时文件路径，避免依赖 `getFile()`。

**单元测试伪代码**：

```java
@SpringBootTest
class JwtServiceTest {
    @Autowired
    private JwtService jwtService;
    
    @Test
    void testGenerateAccessToken() {
        String userId = "123";
        String username = "testuser";
        List<String> roles = Arrays.asList("USER");
        
        String token = jwtService.generateAccessToken(userId, username, roles);
        assertNotNull(token);
        
        Claims claims = jwtService.parseToken(token);
        assertEquals(userId, claims.getSubject());
        assertEquals(username, claims.get("username"));
    }
    
    @Test
    void testTokenExpiration() throws InterruptedException {
        String token = jwtService.generateAccessToken("123", "test", List.of());
        Claims claims = jwtService.parseToken(token);
        assertTrue(claims.getExpiration().after(new Date()));
    }
}
```

**验收标准**：
- ✅ Token 生成和验证功能正常
- ✅ 单元测试通过（至少覆盖 access/refresh 生成与解析、过期/篡改 token 异常、`isTokenExpiringSoon()` 边界）
- ✅ RS256 算法正确实现

---

## 1.4 DTO 定义

### 步骤 1.4.1：创建 RegisterRequest

**文件**：`services/api-common/src/main/java/com/example/api/model/RegisterRequest.java`（新建）

**操作**：
- 创建文件
- 添加字段：`email`（@Email、@NotBlank）、`password`（@NotBlank、@Size(min=8)）
- 添加验证注解

**伪代码示例**：

```java
package com.example.api.model;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;

/**
 * 注册请求 DTO
 * 遵循 OAuth 2.0 标准，使用邮箱和密码注册
 */
@Data
public class RegisterRequest {
    
    /**
     * 用户邮箱
     * 必须符合邮箱格式，不能为空
     */
    @NotBlank(message = "邮箱不能为空")
    @Email(message = "请输入有效的邮箱地址")
    private String email;
    
    /**
     * 用户密码
     * 最少 8 个字符，必须符合密码策略
     * 注意：密码策略验证在服务层进行
     */
    @NotBlank(message = "密码不能为空")
    @Size(min = 8, max = 128, message = "密码长度必须在 8-128 个字符之间")
    private String password;
    
    /**
     * 密码确认（可选，前端验证）
     * 后端不验证此字段，由前端确保两次密码一致
     */
    private String confirmPassword;
}
```

**验证测试代码**：

```java
@Test
void testRegisterRequestValidation() {
    RegisterRequest request = new RegisterRequest();
    
    // 测试空邮箱
    Set<ConstraintViolation<RegisterRequest>> violations = validator.validate(request);
    assertTrue(violations.stream().anyMatch(v -> v.getPropertyPath().toString().equals("email")));
    
    // 测试无效邮箱格式
    request.setEmail("invalid-email");
    violations = validator.validate(request);
    assertTrue(violations.stream().anyMatch(v -> v.getMessage().contains("有效的邮箱地址")));
    
    // 测试密码长度
    request.setEmail("test@example.com");
    request.setPassword("short"); // 少于 8 个字符
    violations = validator.validate(request);
    assertTrue(violations.stream().anyMatch(v -> v.getPropertyPath().toString().equals("password")));
}
```

**验收标准**：
- ✅ DTO 类编译通过
- ✅ 验证注解正确
- ✅ 验证测试通过
- ✅ 单元测试（推荐）：`RegisterRequestValidationTest` 覆盖空值/非法邮箱/密码长度等校验

---

### 步骤 1.4.2：创建 LoginRequest

**文件**：`services/api-common/src/main/java/com/example/api/model/LoginRequest.java`（新建）

**操作**：
- 创建文件
- 添加字段：`email`、`password`、`rememberMe`（可选）

**伪代码示例**：

```java
package com.example.api.model;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;

/**
 * 登录请求 DTO
 * 遵循 OAuth 2.0 Password Grant 模式
 */
@Data
public class LoginRequest {
    
    @NotBlank(message = "邮箱不能为空")
    @Email(message = "请输入有效的邮箱地址")
    private String email;
    
    @NotBlank(message = "密码不能为空")
    private String password;
    
    /**
     * 记住我选项
     * true: Token 有效期延长（Remember Me Token，90 天）
     * false: 标准 Token 有效期（Access Token 30 分钟，Refresh Token 7 天）
     */
    private Boolean rememberMe = false;
}
```

**验收标准**：
- ✅ DTO 类编译通过
- ✅ 字段定义正确
- ✅ 单元测试（推荐）：`LoginRequestValidationTest` 覆盖空值/非法邮箱/空密码等校验

---

### 步骤 1.4.3：创建 LoginResponse

**文件**：`services/api-common/src/main/java/com/example/api/model/LoginResponse.java`（新建）

**操作**：
- 创建文件
- 添加字段：`accessToken`、`tokenType`（固定 "Bearer"）、`expiresIn`、`refreshToken`、`user`
- 遵循 OAuth 2.0 格式

**伪代码示例**：

```java
package com.example.api.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * 登录响应 DTO
 * 严格遵循 OAuth 2.0 Token Response 格式（RFC 6749 Section 5.1）
 * 
 * 参考标准：
 * - OAuth 2.0 (RFC 6749): https://tools.ietf.org/html/rfc6749#section-5.1
 * - Auth0 Token Response: https://auth0.com/docs/api/authentication#get-token
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class LoginResponse {
    
    /**
     * Access Token（访问令牌）
     * OAuth 2.0 标准字段
     */
    @JsonProperty("access_token")
    private String accessToken;
    
    /**
     * Token 类型，固定为 "Bearer"
     * OAuth 2.0 标准字段
     */
    @JsonProperty("token_type")
    private String tokenType = "Bearer";
    
    /**
     * Access Token 有效期（秒）
     * OAuth 2.0 标准字段
     */
    @JsonProperty("expires_in")
    private Long expiresIn;
    
    /**
     * Refresh Token（刷新令牌）
     * OAuth 2.0 标准字段（可选，但推荐实现）
     */
    @JsonProperty("refresh_token")
    private String refreshToken;
    
    /**
     * 权限范围（可选）
     * OAuth 2.0 标准字段
     */
    @JsonProperty("scope")
    private String scope = "read write";
    
    /**
     * 用户信息（扩展字段，非 OAuth 2.0 标准）
     * 包含用户基本信息，便于前端直接使用
     */
    @JsonProperty("user")
    private UserInfo user;
    
    /**
     * 用户信息内部类
     */
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class UserInfo {
        private String id;
        private String email;
        private String username;
        private Boolean emailVerified;
    }
}
```

**响应 JSON 示例**：

```json
{
  "access_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 1800,
  "refresh_token": "dGhpcyBpcyBhIHJlZnJlc2ggdG9rZW4...",
  "scope": "read write",
  "user": {
    "id": "123",
    "email": "user@example.com",
    "username": "testuser",
    "emailVerified": false
  }
}
```

**验收标准**：
- ✅ 响应格式符合 OAuth 2.0 标准
- ✅ 字段命名正确
- ✅ JSON 序列化正常
- ✅（可选增强）序列化测试：`LoginResponseSerializationTest` 断言 JSON 字段名为 `access_token`、`token_type`、`expires_in`、`refresh_token`

---

### 步骤 1.4.4：创建 RefreshTokenRequest

**文件**：`services/api-common/src/main/java/com/example/api/model/RefreshTokenRequest.java`（新建）

**操作**：
- 创建文件
- 添加字段：`refreshToken`（@NotBlank）

**伪代码示例**：

```java
package com.example.api.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;

/**
 * 刷新 Token 请求 DTO
 * 遵循 OAuth 2.0 Refresh Token Grant 模式（RFC 6749 Section 6）
 */
@Data
public class RefreshTokenRequest {
    
    /**
     * Refresh Token
     * 用于获取新的 Access Token
     */
    @NotBlank(message = "Refresh Token 不能为空")
    @JsonProperty("refresh_token")
    private String refreshToken;
}
```

**OAuth 2.0 标准请求格式**：

```json
{
  "grant_type": "refresh_token",
  "refresh_token": "dGhpcyBpcyBhIHJlZnJlc2ggdG9rZW4..."
}
```

**注意**：如果严格遵循 OAuth 2.0，应包含 `grant_type` 字段。本项目简化实现，仅使用 `refreshToken` 字段。

**验收标准**：
- ✅ DTO 类编译通过
- ✅ 验证注解正确
- ✅ 单元测试（推荐）：`RefreshTokenRequestValidationTest` 覆盖 refresh token 为空的校验

---

## 1.5 单元测试（补充）

> 本节补齐第一阶段“后端基础”对应的测试方案与清单。国外主流做法是 **混合策略**：业务逻辑尽量写纯单元测试（快、稳定），配置装配用少量 `@SpringBootTest` 验证（确保 Bean 与属性加载正确）。

### 1.5.1 测试范围（本阶段）

- **`services/user-service`**：
  - `UserEntity` 的敏感字段不泄露（`toDTO()`）
  - `SecurityConfig` 的 `PasswordEncoder` Bean 可用
  - `JwtService` 的 Token 生成/解析/异常/即将过期判断
- **`services/api-common`**：
  - `RegisterRequest` / `LoginRequest` / `RefreshTokenRequest` 的 Bean Validation 校验
  - （可选）`LoginResponse` 的 JSON 字段命名符合 OAuth 2.0

### 1.5.2 测试依赖（Maven，写入实施清单）

> 当前 `services/*` 的 `pom.xml` 暂未包含测试依赖。建议在需要测试的模块中补充如下依赖（本次仅补文档，不修改代码）。

- `org.springframework.boot:spring-boot-starter-test`（JUnit 5 + AssertJ + Spring Test）
- `org.mockito:mockito-junit-jupiter`（如需要 mock）
- 可选增强（用于迁移/数据库验证）：
  - `org.testcontainers:junit-jupiter` + `org.testcontainers:postgresql`（推荐，更贴近生产）
  - 或 `com.h2database:h2`（更轻量，但与 PostgreSQL 行为可能有差异）

### 1.5.3 目录与命名约定

- 测试目录：`services/**/src/test/java`
- 测试包名：与生产代码一致（例如 `com.example.user.service.JwtServiceTest`）
- 用例命名：`shouldXxx_whenYyy`（国外常见，便于阅读与 AI 生成）

### 1.5.4 运行命令（本地）

```bash
# 在仓库根目录执行（运行 services 聚合模块测试）
mvn -f services/pom.xml test

# 仅测试某个模块
mvn -f services/pom.xml -pl user-service test
mvn -f services/pom.xml -pl api-common test
```

### 1.5.5 推荐测试清单（对应本阶段步骤）

- **步骤 1.1.1（UserEntity）**：`UserEntityTest` 断言 `toDTO()` 不包含 `password`
- **步骤 1.1.2（迁移）**：作为“可选增强”补充迁移自动化验证（Testcontainers + Flyway）
- **步骤 1.2.1（SecurityConfig）**：`SecurityConfigTest`（`@SpringBootTest`）验证 `PasswordEncoder` Bean 可用
- **步骤 1.3.3（JwtService）**：`JwtServiceTest` 覆盖 access/refresh、解析校验、过期/篡改异常、`isTokenExpiringSoon` 边界
- **步骤 1.4.1/1.4.2/1.4.4（DTO 校验）**：`*ValidationTest` 覆盖空值、格式、长度等约束
- **步骤 1.4.3（LoginResponse）**：`LoginResponseSerializationTest`（可选）断言 JSON 字段名符合 OAuth 2.0

## 阶段总结

### 完成清单

- [x] 步骤 1.1.1：修改 UserEntity
- [x] 步骤 1.1.2：数据库迁移
- [x] 步骤 1.2.1：创建 SecurityConfig
- [x] 步骤 1.2.2：添加依赖
- [x] 步骤 1.3.1：生成 RSA 密钥对
- [x] 步骤 1.3.2：配置 JWT 属性
- [x] 步骤 1.3.3：创建 JwtService
- [x] 步骤 1.4.1：创建 RegisterRequest
- [x] 步骤 1.4.2：创建 LoginRequest
- [x] 步骤 1.4.3：创建 LoginResponse
- [x] 步骤 1.4.4：创建 RefreshTokenRequest

### 完成情况说明

**状态**：✅ 第一阶段已全部完成（以项目核查为准）。

**实现要点**：

| 步骤 | 实际实现说明 |
|------|--------------|
| 1.1.1 | `UserEntity` 使用 `com.example.api.model.User` 作为 toDTO 返回类型（计划示例为 UserDTO），password 已排除在 toDTO 之外；`UserEntityTest` 覆盖 password 字段约束与 toDTO 不暴露密码。 |
| 1.1.2 | Flyway 迁移脚本 `V2__add_password_to_users.sql` 已存在，为已有用户设置默认 BCrypt 密码。 |
| 1.2.1 | `SecurityConfig` 提供 BCryptPasswordEncoder(12)，并配置 SecurityFilterChain（/api/auth/** 放行、无状态会话）；`SecurityConfigTest` 验证 Bean 与 encode/matches。 |
| 1.3.3 | `JwtService` 使用 `Resource.getInputStream()` 读取密钥（支持 jar 打包），含 `isTokenExpiringSoon()`；`JwtServiceTest` 覆盖 access/refresh 生成解析、篡改/无效 token、issuer/audience、过期时间等。 |
| 1.4.x | DTO 与计划一致；api-common 中已有 `RegisterRequestValidationTest`、`LoginRequestValidationTest`、`RefreshTokenRequestValidationTest`、`LoginResponseSerializationTest`。 |

**测试**：`mvn -f services/pom.xml -pl user-service,api-common test` 已通过。

### 下一步

完成第一阶段后，可以开始 **[第二阶段：后端 API](./02-第二阶段-后端API.md)**
