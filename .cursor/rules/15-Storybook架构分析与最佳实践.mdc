---
description: Storybook 在 monorepo 中的架构分析与跨包依赖最佳实践
alwaysApply: false
globs: apps/storybook/**/* apps/storybook/.storybook/** packages/**/*.stories.*
---

# Storybook 架构分析与最佳实践（Monorepo + 跨包依赖）

本文档分析当前项目中 Storybook 的使用模式，评估跨包依赖（`propel` 使用 `@repo/ui`）的配置是否最佳，并提供改进建议。

## 当前架构分析

### 1) 包职责与依赖关系

```
@repo/ui (基础组件库)
  ├── Button, Input, Card, Sonner 等基础组件
  └── 可添加 stories（在 apps/storybook 中展示）

@repo/propel (增强/包装层)
  ├── 依赖 @repo/ui
  ├── 包装/增强 ui 组件（如 toast 包装 Toaster）
  ├── 提供业务层组件（如 ToggleMode）
  └── 包含 stories（在 apps/storybook 中展示）

@repo/storybook (统一展示入口)
  ├── 独立的 Storybook 应用（apps/storybook/）
  ├── 展示所有包的组件 stories
  └── 符合 Turborepo 官方推荐的主流做法
```

**关键发现**：
- Storybook 已迁移到 `apps/storybook/`（独立应用）
- 统一展示 `propel` 和 `ui` 的组件 stories
- 符合 Turborepo 官方推荐的主流架构模式

### 2) 当前配置评估

#### ✅ 做得好的地方

1. **Monorepo 兼容配置完善**（`apps/storybook/.storybook/main.ts`）：
   ```typescript
   // ✅ 正确：排除 workspace 包避免预构建导致 React 重复
   exclude: ["@repo/ui", "@repo/propel"]
   
   // ✅ 正确：强制 React 去重，避免 hooks dispatcher 为 null
   dedupe: ["react", "react-dom", "scheduler"]
   
   // ✅ 正确：不保留 symlink，避免路径解析问题
   preserveSymlinks: false
   
   // ✅ 正确：允许访问父目录（workspace 包）
   server.fs.allow: [父目录路径]
   ```

2. **样式注入合理**（`preview.ts`）：
   - 全局引入 `@repo/tailwind-config/shared-styles`
   - 通过 decorator 提供主题变量兜底

3. **Docker 构建使用 `turbo prune`**：
   - 自动分析并只包含 `storybook` 及其依赖（包括 `propel`、`ui`）
   - 避免复制整个 monorepo

#### ⚠️ 潜在问题与改进空间

1. **职责边界不够清晰**：
   - Storybook 放在 `propel` 中，但展示的是 `propel` + `ui` 的组件
   - 如果未来 `ui` 包也需要独立展示自己的组件，当前方案不够灵活

2. **Story 路径配置可以更精确**：
   ```typescript
   // 当前：可能误加载 node_modules 中的 story（虽然概率低）
   stories: ["../src/**/*.stories.@(js|jsx|mjs|ts|tsx)"]
   
   // 建议：更明确的排除规则
   stories: [
     "../src/**/*.stories.@(js|jsx|mjs|ts|tsx)",
     "!../node_modules/**"
   ]
   ```

3. **跨包依赖的构建性能**：
   - 每次 Storybook 启动都会重新解析 `@repo/ui` 的源码
   - 如果 `ui` 包很大，可能影响启动速度

## 三种常见架构模式对比

### 模式 A：每个包独立的 Storybook（适合大型 monorepo）

```
packages/
  ├── ui/
  │   └── .storybook/  # ui 自己的 Storybook
  └── propel/
      └── .storybook/  # propel 自己的 Storybook
```

**优点**：
- 职责清晰，每个包独立管理
- 适合大型 monorepo，包之间相对独立

**缺点**：
- 维护成本高（多个 Storybook 配置）
- 无法在一个地方看到所有组件

**适用场景**：包之间耦合度低，各自有独立的组件库定位

### 模式 B：统一的 Storybook（适合中小型 monorepo）

**变体 B1：根目录 `.storybook/`（较少见）**

```
.storybook/  # 在 monorepo 根目录
  ├── main.ts
  └── preview.ts

packages/
  ├── ui/src/**/*.stories.tsx
  └── propel/src/**/*.stories.tsx
```

**变体 B2：独立 Storybook App（Turborepo 官方推荐，更主流）**

```
apps/
  └── storybook/  # 独立的 Storybook 应用
      └── .storybook/
packages/
  ├── ui/src/**/*.stories.tsx
  └── propel/src/**/*.stories.tsx
```

**优点**：
- 统一入口，所有组件在一个 Storybook 中
- 配置集中，维护成本低
- **B2 变体**：作为独立 app，更符合 monorepo 的 `apps/` 和 `packages/` 分离原则

**缺点**：
- 需要处理多个包的依赖关系
- 构建时间可能较长
- **B1 变体**：根目录 `.storybook/` 在大型项目中可能与其他工具配置冲突

**适用场景**：
- **B1**：中小型 monorepo，包之间耦合度高，且没有使用 `apps/` 目录结构
- **B2**：使用 Turborepo 或类似工具，有明确的 `apps/` 和 `packages/` 分离

**主流做法评估**：
- ❌ **根目录 `.storybook/`（B1）不是主流做法**：在大型开源项目中较少见
- ✅ **`apps/storybook/`（B2）是主流做法**：Turborepo 官方推荐，被许多设计系统项目采用

### 模式 C：Storybook 在增强层（propel）- **已迁移**

```
packages/
  ├── ui/  # 无 Storybook
  └── propel/
      └── .storybook/  # 展示 propel + ui 组件（已废弃）
```

**状态**：已迁移到模式 B2（`apps/storybook/`）

### 模式 D：当前方案 - 独立 Storybook App（apps/storybook）

```
apps/
  └── storybook/  # 独立的 Storybook 应用
      └── .storybook/
packages/
  ├── ui/src/**/*.stories.tsx
  └── propel/src/**/*.stories.tsx
```

**优点**：
- ✅ 符合 Turborepo 官方推荐的主流做法
- ✅ 职责清晰（独立 app）
- ✅ 扩展性强（可轻松添加新包的 stories）
- ✅ 符合 monorepo 的 `apps/` 和 `packages/` 分离原则

**缺点**：
- 需要处理多个包的依赖关系（但配置已完善）

**适用场景**：使用 Turborepo，有明确的 `apps/` 和 `packages/` 分离

## 当前方案评估结论

### ✅ 已迁移到**主流最佳实践**（模式 B2）

**当前架构**：
1. **符合 Turborepo 官方推荐**：Storybook 作为独立 app 放在 `apps/storybook/`
2. **配置完善**：monorepo 兼容配置、React 去重、样式注入都已正确处理
3. **构建流程合理**：使用 `turbo prune` 自动处理依赖关系
4. **扩展性强**：可轻松添加新包的 stories（如 `packages/ui/src/**/*.stories.tsx`）

### ✅ 已完成的改进

1. **明确 Story 的归属**：
   - `propel/xxx`：propel 包的组件
   - `ui/xxx`：ui 包的组件（未来可添加）

2. **已迁移到主流架构**：
   - ✅ 已迁移到 `apps/storybook/`（模式 B2）
   - ✅ 统一展示所有包的组件
   - ✅ 符合 Turborepo 官方推荐

3. **配置优化**：
   - ✅ 跨包 stories 路径配置完善
   - ✅ 排除规则包含所有 workspace 包
   - ✅ 直接引用源码（简单且高效）

## 推荐的最佳实践（当前已实现）

### 1) 统一 Storybook 架构（✅ 已实现）

**约定**：
- `apps/storybook/` 是"组件库统一展示入口"
- Story 的 `title` 明确区分：
  - `propel/xxx`：propel 包的组件
  - `ui/xxx`：ui 包的组件（未来可添加）

### 2) 配置优化（✅ 已实现）

```typescript
// apps/storybook/.storybook/main.ts
const config: StorybookConfig = {
  stories: [
    "../../packages/propel/src/**/*.stories.@(js|jsx|mjs|ts|tsx)",
    "../../packages/ui/src/**/*.stories.@(js|jsx|mjs|ts|tsx)",
    // 明确排除 node_modules，避免误加载
    "!../../**/node_modules/**",
  ],
  // ... 其他配置已完善
}
```

### 3) 文档化约定（✅ 已更新）

在 `.cursor/rules/14-Storybook使用规范.mdc` 中已明确：
- Storybook 的定位：组件库统一展示入口（`apps/storybook/`）
- Story 命名约定：按包名分组（`propel/`、`ui/`）
- 跨包依赖的处理方式

## 未来扩展（已支持）

### 场景：`ui` 包也需要添加 stories

**当前方案已支持**：✅ 无需额外配置

1. 在 `packages/ui/src/` 下创建 `*.stories.tsx` 文件
2. `apps/storybook/.storybook/main.ts` 已包含 `packages/ui/src/**/*.stories.@(js|jsx|mjs|ts|tsx)`
3. Story 的 `title` 使用 `ui/xxx` 格式

**示例**：
```typescript
// packages/ui/src/button/button.stories.tsx
const meta: Meta<typeof Button> = {
  title: "ui/button",  // ui 包的组件
  component: Button,
}
```

**优势**：当前架构已支持跨包展示，无需额外配置

## 国外主流做法调研

### 1) Turborepo 官方推荐（最主流）

**Turborepo 官方文档明确推荐**：将 Storybook 作为独立的 app 放在 `apps/storybook/` 目录。

```
apps/
  └── storybook/  # 独立的 Storybook 应用
      ├── .storybook/
      └── package.json
packages/
  ├── ui/
  └── propel/
```

**理由**：
- 符合 monorepo 的 `apps/` 和 `packages/` 分离原则
- Storybook 被视为一个"应用"而非配置
- 便于独立构建、部署和版本管理

**参考**：[Turborepo Storybook 指南](https://turbo.build/docs/guides/tools/storybook)

### 2) Storybook 官方社区讨论

根据 Storybook 官方 GitHub 讨论，monorepo 中主要有两种方式：

1. **每个包独立的 Storybook + Composition**（适合大型项目）
   - 每个包有自己的 `.storybook/`
   - 使用 Storybook Composition 组合成统一界面
   - 优点：包之间完全解耦，可独立部署

2. **统一的 Storybook（根目录或独立 app）**（适合中小型项目）
   - 单一 Storybook 配置，通过 glob 包含所有包的 stories
   - 优点：配置简单，统一管理

**官方态度**：Storybook 目前**没有官方推荐的主流做法**，两种方式都可行，取决于项目规模。

### 3) 实际开源项目调研

**常见做法排序**（从最常见到较少见）：

1. ✅ **`apps/storybook/`（独立 app）** - 最常见
   - 被 Turborepo 官方推荐
   - 许多设计系统项目采用（如 Radix UI 生态、Chakra UI 等）

2. ✅ **每个包独立的 Storybook** - 常见于大型项目
   - 适合包之间相对独立的场景
   - 使用 Composition 组合

3. ⚠️ **根目录 `.storybook/`** - 较少见
   - 在大型开源项目中较少采用
   - 可能与根目录其他配置文件冲突

4. ✅ **Storybook 在某个包中（当前方案）** - 合理但非主流
   - 适合"增强层"场景（如当前项目的 `propel`）
   - 配置相对简单

### 4) 当前项目方案 vs 主流做法

| 维度 | 当前方案（`apps/storybook/`） | 状态 |
|------|---------------------------|------|
| **符合主流** | ✅ 最主流（Turborepo 推荐） | ✅ **已实现** |
| **配置复杂度** | ⚠️ 中等（需要处理所有包依赖） | ✅ 配置已完善 |
| **职责清晰度** | ✅ 清晰（独立 app） | ✅ **已实现** |
| **扩展性** | ✅ 灵活（可轻松添加新包的 stories） | ✅ **已实现** |
| **构建性能** | ⚠️ 可能较慢（需要处理所有包） | ✅ 使用 `turbo prune` 优化 |

**结论**：
- ✅ 当前方案**已迁移到主流做法**（`apps/storybook/`）
- ✅ 符合 Turborepo 官方推荐
- ✅ 配置完善，支持跨包展示
- ✅ 扩展性强，未来可轻松添加新包的 stories

## 总结

当前方案（**模式 B2：`apps/storybook/`**）已迁移到**主流最佳实践**。主要优势：
- ✅ **符合 Turborepo 官方推荐的主流做法**
- ✅ 配置完善，正确处理了 monorepo 跨包依赖
- ✅ 职责清晰（独立 app）
- ✅ 构建流程合理（使用 `turbo prune`）
- ✅ 扩展性强（可轻松添加新包的 stories）

**已完成的改进**：
- ✅ 迁移到 `apps/storybook/`（独立应用）
- ✅ 统一展示所有包的组件 stories
- ✅ 明确 Story 命名约定（按包名分组）
- ✅ 更新文档和 CI/CD 配置

**当前状态**：
- ✅ 架构符合主流最佳实践
- ✅ 配置完善，支持跨包展示
- ✅ 未来可轻松扩展（添加 `ui` 或其他包的 stories）
